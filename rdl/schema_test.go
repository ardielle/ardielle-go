// Copyright 2015 Yahoo Inc.
// Licensed under the terms of the Apache version 2.0 license. See LICENSE file for terms.

package rdl

import (
	"encoding/json"
	"fmt"
	"os"
	"testing"
	"time"
)

func expectJSON(test *testing.T, val interface{}, expected string) {
	j, err := json.Marshal(val)
	if err != nil {
		test.Errorf("Cannot JSON marshal: %v", val)
	}
	sj := string(j)
	if sj != expected {
		test.Errorf("Unexpected marshal'd value: %s", sj)
	}
	//	fmt.Println(val, "=>", sj)
}

type TimestampTestStruct struct {
	ID  UUID       `json:"id"`
	Ref *UUID      `json:"ref,omitempty"`
	T1  Timestamp  `json:"t1"`
	T2  *Timestamp `json:"t2,omitempty"` //optional requires pointer, though idiom is non-pointer or time.Time
	Sym Symbol     `json:"sym,omitempty"`
}

func (ts *TimestampTestStruct) String() string {
	b, e := json.Marshal(ts)
	if e != nil {
		return "<TimestampTestStruct>"
	}
	return string(b)
}

func TestTimestamp(test *testing.T) {
	t := time.Now().UTC()
	ts1 := NewTimestamp(t)
	if ts1.Validate() != nil {
		test.Errorf("Cannot create timestamp from time.Time")
	}
	ts1a := Timestamp{t}
	if ts1 != ts1a {
		test.Errorf("%v should be equal to %v", ts1, ts1a)
	}
	ts2 := TimestampNow()
	if ts2.Validate() != nil {
		test.Errorf("Cannot create timestamp from current time")
	}
	ts3, err := TimestampParse("2015-03-14T15:59:26.535Z")
	if err != nil {
		test.Errorf("Cannot parse timestamp: %v", err)
	}
	fmt.Println("ts3:", ts3)
	if ts3.Validate() != nil {
		test.Errorf("Cannot parse timestamp")
	}
	ts4, err := TimestampParse("2015-03-14T15:59:26.535+00:00")
	if err != nil {
		test.Errorf("Cannot parse timestamp: %v", err)
	}
	fmt.Println("ts4:", ts4)
	if ts3.Validate() != nil {
		test.Errorf("Cannot parse timestamp")
	}
	expectJSON(test, ts4, `"2015-03-14T15:59:26.535Z"`)
	var tt TimestampTestStruct
	tt.ID = ParseUUID("275a2ede-ca77-11e4-9b30-003ee1be85f9")
	tt.T1 = ts3
	expectJSON(test, tt, `{"id":"275a2ede-ca77-11e4-9b30-003ee1be85f9","t1":"2015-03-14T15:59:26.535Z"}`)
}

func TestUUID(test *testing.T) {
	//any UUID generator that produces a []byte will work, i.e.:
	//    import "google.com/p/go-uuid/uuid"
	//    u0 := NewUUID(uuid.NewUUID())
	//    fmt.Println("new time-based uuid:", u0)
	u1 := ParseUUID("275a2ede-ca77-11e4-9b30-003ee1be85f9")
	if u1 == nil {
		test.Errorf("Valid UUID did not parse: %s", u1)
	}
	for _, u := range []string{
		"",
		"whatever",
		"whatever-this-isnt-good-becauseofhex",
		"275a2ede!ca77-11e4-9b30-003ee1be85f9",
		"275a2ede-ca77x11e4-9b30-003ee1be85f9",
		"275a2ede-ca77-11e4x9b30-003ee1be85f9",
	} {
		ubad := ParseUUID(u)
		if ubad != nil {
			test.Errorf("Bad UUID parsed when it shouldn't have: %s", u)
		}
	}
	b := []byte(u1)
	if len(b) != 16 {
		test.Errorf("Bad byte array for UUID")
	}
	fmt.Println("b:", b)
	u2 := NewUUID(b)
	fmt.Println("u2:", u2)
}

func TestSymbol(test *testing.T) {
	sym1 := Symbol("test1")
	expectJSON(test, sym1, `"test1"`)
	t := TimestampTestStruct{Sym: sym1}
	expectJSON(test, t, `{"id":"00000000-0000-0000-0000-000000000000","t1":"","sym":"test1"}`)

}

func TestModelSerialization(test *testing.T) {
	files := []string{"u1s1.json", "u1s2.json", "u1s3.json"}
	for _, filename := range files {
		bytes, err := os.ReadFile("../testdata/" + filename)
		if err != nil {
			fmt.Printf("Cannot read data(%s): %v", filename, err)
			test.Errorf("Cannot read data(%s): %v", filename, err)
		}
		var data U1
		err = json.Unmarshal(bytes, &data)
		if err != nil {
			fmt.Printf("Cannot decode data(%s): %v", filename, err)
			test.Errorf("Cannot decode data(%s): %v", filename, err)
		}
		switch data.Variant {
		case U1VariantS1:
			if filename != "u1s1.json" {
				test.Errorf("Bad decode: data in %s decoded as variant S1", filename)
			}
			fmt.Println("S1 variant of U1:", *data.S1)
		case U1VariantS2:
			if filename != "u1s2.json" {
				test.Errorf("Bad decode: data in %s decoded as variant S2", filename)
			}
			fmt.Println("S2 variant of U1:", *data.S2)
		case U1VariantS3:
			if filename != "u1s3.json" {
				test.Errorf("Bad decode: data in %s decoded as variant S3", filename)
			}
			s3 := *data.S3
			fmt.Println("S2 variant of U1 = x:", s3.X, "y:", s3.Z)
		}
	}
}

// the rest of this file was generated by running 'rdl-command --gen go-model ../testdata/u1.rdl
//
// S2 -
type S2 struct {
	X int32 `json:"x"`
	Y int32 `json:"y"`
}

// S3 -
type S3 struct {
	X int32 `json:"x"`
	Z int32 `json:"z"`
}

// U1 -
type U1VariantTag int

const (
	_ U1VariantTag = iota
	U1VariantS1
	U1VariantS2
	U1VariantS3
)

type U1 struct {
	Variant U1VariantTag
	S1      *string
	S2      *S2
	S3      *S3
}

func (u U1) String() string {
	switch u.Variant {
	case U1VariantS1:
		return fmt.Sprintf("%v", u.S1)
	case U1VariantS2:
		return fmt.Sprintf("%v", u.S2)
	case U1VariantS3:
		return fmt.Sprintf("%v", u.S3)
	default:
		return "<U1 uninitialized>"
	}
}

func (u U1) MarshalJSON() ([]byte, error) {
	switch u.Variant {
	case U1VariantS1:
		return json.Marshal(u.S1)
	case U1VariantS2:
		return json.Marshal(u.S2)
	case U1VariantS3:
		return json.Marshal(u.S3)
	default:
		return nil, fmt.Errorf("Cannot marshal uninitialized union type U1")
	}
}

func checkU1StructFields(repr map[string]interface{}, fields ...string) bool {
	for _, s := range fields {
		if _, ok := repr[s]; !ok {
			return false
		}
	}
	return true
}

func makeU1VariantS2(b []byte, u *U1, fields map[string]interface{}) bool {
	if checkU1StructFields(fields, "x", "y") {
		var o S2
		if err := json.Unmarshal(b, &o); err == nil {
			up := new(U1)
			up.Variant = U1VariantS2
			up.S2 = &o
			*u = *up
			return true
		}
	}
	return false
}

func makeU1VariantS3(b []byte, u *U1, fields map[string]interface{}) bool {
	if checkU1StructFields(fields, "x", "z") {
		var o S3
		if err := json.Unmarshal(b, &o); err == nil {
			up := new(U1)
			up.Variant = U1VariantS3
			up.S3 = &o
			*u = *up
			return true
		}
	}
	return false
}

func (u *U1) UnmarshalJSON(b []byte) error {
	var tmp interface{}
	if err := json.Unmarshal(b, &tmp); err != nil {
		return err
	}
	switch v := tmp.(type) {
	case map[string]interface{}:
		if makeU1VariantS2(b, u, v) {
			return nil
		}
		if makeU1VariantS3(b, u, v) {
			return nil
		}
	case string:
		*u = U1{U1VariantS1, &v, nil, nil}
		return nil
	}
	return fmt.Errorf("Cannot unmarshal JSON to union type U1")
}
